{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { posix } from 'path';\nimport { exports as resolveExports } from 'resolve.exports';\nimport memoize from 'mem';\n\ntype PkgJSON = { name: string; version: string; exports?: Exports };\ntype Exports = string | string[] | { [key: string]: Exports };\n\n/**\n * An util to find a string value in a nested JSON-like structure.\n *\n * Receives an object (a netsted JSON-like structure) and a matcher callback\n * that is tested against each string value.\n *\n * When a value is found, returns an object containing a `value` and a `key`.\n * The key is one of the parent keys of the found value â€” the one that starts\n * with `.`.\n *\n * When a value is not found, returns `undefined`.\n */\nexport function _findPathRecursively(\n  exportsObj: Exports,\n  matcher: (path: string) => boolean,\n  key = '.'\n): { key: string; value: Exports } | undefined {\n  if (typeof exportsObj === 'string') {\n    return matcher(exportsObj) ? { key, value: exportsObj } : undefined;\n  }\n\n  if (Array.isArray(exportsObj)) {\n    const value = exportsObj.find(path => matcher(path));\n\n    if (value) {\n      return { key, value };\n    } else {\n      return undefined;\n    }\n  }\n\n  if (typeof exportsObj === 'object') {\n    let result: { key: string; value: Exports } | undefined = undefined;\n\n    for (const candidateKey in exportsObj) {\n      if (!exportsObj.hasOwnProperty(candidateKey)) {\n        return;\n      }\n\n      const candidate = _findPathRecursively(exportsObj[candidateKey], matcher, key);\n\n      if (candidate) {\n        result = {\n          key: candidateKey,\n          value: candidate.value,\n        };\n\n        break;\n      }\n    }\n\n    if (result) {\n      if (result.key.startsWith('./')) {\n        if (key !== '.') {\n          throw new Error(`exportsObj contains doubly nested path keys: \"${key}\" and \"${result.key}\"`);\n        }\n\n        return { key: result.key, value: result.value };\n      } else {\n        return { key, value: result.value };\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  throw new Error(`Unexpected type of obj: ${typeof exportsObj}`);\n}\n\n/*\n  Takes a relativePath that is relative to the package root and produces its\n  externally-addressable name.\n\n  Returns undefined for a relativePath that is forbidden to be accessed from the\n  outside.\n*/\nfunction _externalName(pkg: PkgJSON, relativePath: string): string | undefined {\n  let { exports } = pkg;\n  if (!exports) {\n    return posix.join(pkg.name, relativePath);\n  }\n\n  const maybeKeyValuePair = _findPathRecursively(exports, candidate => _matches(candidate, relativePath));\n\n  if (!maybeKeyValuePair) {\n    return undefined;\n  }\n\n  const { key, value } = maybeKeyValuePair;\n\n  if (typeof value !== 'string') {\n    throw new Error('Expected value to be a string');\n  }\n\n  const maybeResolvedPaths = resolveExports({ name: pkg.name, exports: { [value]: key } }, relativePath);\n\n  if (!maybeResolvedPaths) {\n    throw new Error(\n      `Bug Discovered! \\`_findPathRecursively()\\` must always return a string value but instead it found a ${typeof value}. Please report this as an issue to https://github.com/embroider-build/embroider/issues/new`\n    );\n  }\n\n  const [resolvedPath] = maybeResolvedPaths;\n\n  return posix.join(pkg.name, resolvedPath);\n}\n\nexport const externalName = memoize(_externalName, {\n  cacheKey: ([pkg, relativePath]) => `${pkg.name}::${pkg.version}::${relativePath}`,\n});\n\nfunction _regexEscape(input: string): string {\n  return input.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nconst regexEscape = memoize(_regexEscape);\n\nexport function _matches(candidate: string, relativePath: string): boolean {\n  let wildCardIndex = candidate.indexOf('*');\n\n  if (~wildCardIndex) {\n    return new RegExp(\n      `^${regexEscape(candidate.substring(0, wildCardIndex))}.*${regexEscape(candidate.substring(wildCardIndex + 1))}$`\n    ).test(relativePath);\n  } else {\n    return candidate === relativePath;\n  }\n}\n"]}